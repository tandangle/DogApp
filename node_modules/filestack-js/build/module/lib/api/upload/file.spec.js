import { __awaiter, __generator } from "tslib";
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { File } from './file';
describe('Api/Upload/File', function () {
    var testBuff = Buffer.from('test');
    var fileName = 'text.txt';
    var type = 'text/plain';
    var fi = {
        name: fileName,
        type: type,
        size: testBuff.byteLength,
        slice: function (start, end) { return Promise.resolve(testBuff.slice(start, end)); },
    };
    var file;
    beforeEach(function () {
        file = new File(Object.assign({}, fi));
    });
    it('Should load correct file without errors', function () {
        expect(file.filename).toEqual(fileName);
        expect(file.name).toEqual(fileName);
        expect(file.type).toEqual(type);
        expect(file.mimetype).toEqual(type);
        expect(file.size).toEqual(testBuff.byteLength);
    });
    it('should allow to set new name with with sanitization', function () {
        file.name = 'test123//.txt';
        expect(file.name).toEqual('test123//.txt');
    });
    it('should set custom name by string and sanitize it', function () {
        file.customName = 'test123##.txt';
        expect(file.name).toEqual('test123--.txt');
    });
    it('should set custom name by function and sanitize it', function () {
        file.customName = function () {
            return 'test123 ##.txt';
        };
        expect(file.name).toEqual('test123 --.txt');
    });
    it('should throw an error when custom name function is not returning string', function () {
        expect(function () {
            file.customName = function () {
                return {};
            };
        }).toThrow();
    });
    it('should return correct parts count for given size', function () {
        expect(file.getPartsCount(1)).toEqual(file.size);
    });
    it('should return correct part metadata', function () {
        expect(file.getPartMetadata(0, 2)).toEqual({ endByte: 2, partNumber: 0, size: 2, startByte: 0 });
        expect(file.getPartMetadata(1, 2)).toEqual({ endByte: 4, partNumber: 1, size: 2, startByte: 2 });
        expect(file.getPartMetadata(0, 6)).toEqual({ endByte: 4, partNumber: 0, size: 4, startByte: 0 });
    });
    it('should throw an error when start part is higher than part size ', function () {
        expect(function () {
            file.getPartMetadata(1, 6);
        }).toThrow();
    });
    it('should return part by part metadata', function () { return __awaiter(void 0, void 0, void 0, function () {
        var meta, part;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    meta = file.getPartMetadata(0, 2);
                    return [4 /*yield*/, file.getPartByMetadata(meta)];
                case 1:
                    part = _a.sent();
                    expect(part.size).toEqual(2);
                    expect(part.md5).toEqual('Vp73JkK+D63XEdakaNaO4Q==');
                    return [2 /*return*/];
            }
        });
    }); });
    it('should not calc chunk md5 on disable param', function () { return __awaiter(void 0, void 0, void 0, function () {
        var meta, part;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    meta = file.getPartMetadata(0, 2);
                    return [4 /*yield*/, file.getPartByMetadata(meta, false)];
                case 1:
                    part = _a.sent();
                    expect(part.size).toEqual(2);
                    expect(part.md5).toEqual(undefined);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should return chunk by part metadata and offset', function () { return __awaiter(void 0, void 0, void 0, function () {
        var meta, chunk;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    meta = file.getPartMetadata(0, 4);
                    return [4 /*yield*/, file.getChunkByMetadata(meta, 1, 2)];
                case 1:
                    chunk = _a.sent();
                    expect(chunk.size).toEqual(2);
                    expect(chunk.md5).toEqual('EkcP5AbUQBfZbqs33WX8FA==');
                    expect(chunk.startByte).toEqual(1);
                    expect(chunk.endByte).toEqual(3);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should not calc chunk md5 on disable param', function () { return __awaiter(void 0, void 0, void 0, function () {
        var meta, chunk;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    meta = file.getPartMetadata(0, 4);
                    return [4 /*yield*/, file.getChunkByMetadata(meta, 1, 2, false)];
                case 1:
                    chunk = _a.sent();
                    expect(chunk.size).toEqual(2);
                    expect(chunk.md5).toEqual(undefined);
                    expect(chunk.startByte).toEqual(1);
                    expect(chunk.endByte).toEqual(3);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should release file buffer', function () {
        file.release();
        expect(file.buffer).toEqual(undefined);
    });
    it('should return json representation of the file', function () {
        var json = JSON.parse(JSON.stringify(file));
        expect(json).toEqual({
            name: fileName,
            type: type,
            size: file.size,
        });
    });
});

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlLnNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE9BQU8sRUFBZ0IsSUFBSSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRTVDLFFBQVEsQ0FBQyxpQkFBaUIsRUFBRTtJQUMxQixJQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3JDLElBQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQztJQUM1QixJQUFNLElBQUksR0FBRyxZQUFZLENBQUM7SUFFMUIsSUFBTSxFQUFFLEdBQWlCO1FBQ3ZCLElBQUksRUFBRSxRQUFRO1FBQ2QsSUFBSSxNQUFBO1FBQ0osSUFBSSxFQUFFLFFBQVEsQ0FBQyxVQUFVO1FBQ3pCLEtBQUssRUFBRSxVQUFDLEtBQUssRUFBRSxHQUFHLElBQUssT0FBQSxPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQTNDLENBQTJDO0tBQ25FLENBQUM7SUFFRixJQUFJLElBQUksQ0FBQztJQUVULFVBQVUsQ0FBQztRQUNULElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLHlDQUF5QyxFQUFFO1FBQzVDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3hDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXBDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hDLE1BQU0sQ0FBQyxJ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LElBQUk7U0FDaEIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsImZpbGUiOiJsaWIvYXBpL3VwbG9hZC9maWxlLnNwZWMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBGaWxlSW5zdGFuY2UsIEZpbGUgfSBmcm9tICcuL2ZpbGUnO1xuXG5kZXNjcmliZSgnQXBpL1VwbG9hZC9GaWxlJywgKCkgPT4ge1xuICBjb25zdCB0ZXN0QnVmZiA9IEJ1ZmZlci5mcm9tKCd0ZXN0Jyk7XG4gIGNvbnN0IGZpbGVOYW1lID0gJ3RleHQudHh0JztcbiAgY29uc3QgdHlwZSA9ICd0ZXh0L3BsYWluJztcblxuICBjb25zdCBmaTogRmlsZUluc3RhbmNlID0ge1xuICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgIHR5cGUsXG4gICAgc2l6ZTogdGVzdEJ1ZmYuYnl0ZUxlbmd0aCxcbiAgICBzbGljZTogKHN0YXJ0LCBlbmQpID0+IFByb21pc2UucmVzb2x2ZSh0ZXN0QnVmZi5zbGljZShzdGFydCwgZW5kKSksXG4gIH07XG5cbiAgbGV0IGZpbGU7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgZmlsZSA9IG5ldyBGaWxlKE9iamVjdC5hc3NpZ24oe30sIGZpKSk7XG4gIH0pO1xuXG4gIGl0KCdTaG91bGQgbG9hZCBjb3JyZWN0IGZpbGUgd2l0aG91dCBlcnJvcnMnLCAoKSA9PiB7XG4gICAgZXhwZWN0KGZpbGUuZmlsZW5hbWUpLnRvRXF1YWwoZmlsZU5hbWUpO1xuICAgIGV4cGVjdChmaWxlLm5hbWUpLnRvRXF1YWwoZmlsZU5hbWUpO1xuXG4gICAgZXhwZWN0KGZpbGUudHlwZSkudG9FcXVhbCh0eXBlKTtcbiAgICBleHBlY3QoZmlsZS5taW1ldHlwZSkudG9FcXVhbCh0eXBlKTtcblxuICAgIGV4cGVjdChmaWxlLnNpemUpLnRvRXF1YWwodGVzdEJ1ZmYuYnl0ZUxlbmd0aCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWxsb3cgdG8gc2V0IG5ldyBuYW1lIHdpdGggd2l0aCBzYW5pdGl6YXRpb24nLCAoKSA9PiB7XG4gICAgZmlsZS5uYW1lID0gJ3Rlc3QxMjMvLy50eHQnO1xuXG4gICAgZXhwZWN0KGZpbGUubmFtZSkudG9FcXVhbCgndGVzdDEyMy8vLnR4dCcpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHNldCBjdXN0b20gbmFtZSBieSBzdHJpbmcgYW5kIHNhbml0aXplIGl0JywgKCkgPT4ge1xuICAgIGZpbGUuY3VzdG9tTmFtZSA9ICd0ZXN0MTIzIyMudHh0JztcblxuICAgIGV4cGVjdChmaWxlLm5hbWUpLnRvRXF1YWwoJ3Rlc3QxMjMtLS50eHQnKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBzZXQgY3VzdG9tIG5hbWUgYnkgZnVuY3Rpb24gYW5kIHNhbml0aXplIGl0JywgKCkgPT4ge1xuICAgIGZpbGUuY3VzdG9tTmFtZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiAndGVzdDEyMyAjIy50eHQnO1xuICAgIH07XG5cbiAgICBleHBlY3QoZmlsZS5uYW1lKS50b0VxdWFsKCd0ZXN0MTIzIC0tLnR4dCcpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHRocm93IGFuIGVycm9yIHdoZW4gY3VzdG9tIG5hbWUgZnVuY3Rpb24gaXMgbm90IHJldHVybmluZyBzdHJpbmcnLCAoKSA9PiB7XG4gICAgZXhwZWN0KCgpID0+IHtcbiAgICAgIGZpbGUuY3VzdG9tTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfTtcbiAgICB9KS50b1Rocm93KCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmV0dXJuIGNvcnJlY3QgcGFydHMgY291bnQgZm9yIGdpdmVuIHNpemUnLCAoKSA9PiB7XG4gICAgZXhwZWN0KGZpbGUuZ2V0UGFydHNDb3VudCgxKSkudG9FcXVhbChmaWxlLnNpemUpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiBjb3JyZWN0IHBhcnQgbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgZXhwZWN0KGZpbGUuZ2V0UGFydE1ldGFkYXRhKDAsIDIpKS50b0VxdWFsKHsgZW5kQnl0ZTogMiwgcGFydE51bWJlcjogMCwgc2l6ZTogMiwgc3RhcnRCeXRlOiAwIH0pO1xuICAgIGV4cGVjdChmaWxlLmdldFBhcnRNZXRhZGF0YSgxLCAyKSkudG9FcXVhbCh7IGVuZEJ5dGU6IDQsIHBhcnROdW1iZXI6IDEsIHNpemU6IDIsIHN0YXJ0Qnl0ZTogMiB9KTtcbiAgICBleHBlY3QoZmlsZS5nZXRQYXJ0TWV0YWRhdGEoMCwgNikpLnRvRXF1YWwoeyBlbmRCeXRlOiA0LCBwYXJ0TnVtYmVyOiAwLCBzaXplOiA0LCBzdGFydEJ5dGU6IDAgfSk7XG5cbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciB3aGVuIHN0YXJ0IHBhcnQgaXMgaGlnaGVyIHRoYW4gcGFydCBzaXplICcsICgpID0+IHtcbiAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgZmlsZS5nZXRQYXJ0TWV0YWRhdGEoMSwgNik7XG4gICAgfSkudG9UaHJvdygpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiBwYXJ0IGJ5IHBhcnQgbWV0YWRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbWV0YSA9IGZpbGUuZ2V0UGFydE1ldGFkYXRhKDAsIDIpO1xuICAgIGNvbnN0IHBhcnQgPSBhd2FpdCBmaWxlLmdldFBhcnRCeU1ldGFkYXRhKG1ldGEpO1xuXG4gICAgZXhwZWN0KHBhcnQuc2l6ZSkudG9FcXVhbCgyKTtcbiAgICBleHBlY3QocGFydC5tZDUpLnRvRXF1YWwoJ1ZwNzNKa0srRDYzWEVkYWthTmFPNFE9PScpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5vdCBjYWxjIGNodW5rIG1kNSBvbiBkaXNhYmxlIHBhcmFtJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1ldGEgPSBmaWxlLmdldFBhcnRNZXRhZGF0YSgwLCAyKTtcbiAgICBjb25zdCBwYXJ0ID0gYXdhaXQgZmlsZS5nZXRQYXJ0QnlNZXRhZGF0YShtZXRhLCBmYWxzZSk7XG5cbiAgICBleHBlY3QocGFydC5zaXplKS50b0VxdWFsKDIpO1xuICAgIGV4cGVjdChwYXJ0Lm1kNSkudG9FcXVhbCh1bmRlZmluZWQpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiBjaHVuayBieSBwYXJ0IG1ldGFkYXRhIGFuZCBvZmZzZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbWV0YSA9IGZpbGUuZ2V0UGFydE1ldGFkYXRhKDAsIDQpO1xuICAgIGNvbnN0IGNodW5rID0gYXdhaXQgZmlsZS5nZXRDaHVua0J5TWV0YWRhdGEobWV0YSwgMSwgMik7XG5cbiAgICBleHBlY3QoY2h1bmsuc2l6ZSkudG9FcXVhbCgyKTtcbiAgICBleHBlY3QoY2h1bmsubWQ1KS50b0VxdWFsKCdFa2NQNUFiVVFCZlpicXMzM1dYOEZBPT0nKTtcbiAgICBleHBlY3QoY2h1bmsuc3RhcnRCeXRlKS50b0VxdWFsKDEpO1xuICAgIGV4cGVjdChjaHVuay5lbmRCeXRlKS50b0VxdWFsKDMpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5vdCBjYWxjIGNodW5rIG1kNSBvbiBkaXNhYmxlIHBhcmFtJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1ldGEgPSBmaWxlLmdldFBhcnRNZXRhZGF0YSgwLCA0KTtcbiAgICBjb25zdCBjaHVuayA9IGF3YWl0IGZpbGUuZ2V0Q2h1bmtCeU1ldGFkYXRhKG1ldGEsIDEsIDIsIGZhbHNlKTtcblxuICAgIGV4cGVjdChjaHVuay5zaXplKS50b0VxdWFsKDIpO1xuICAgIGV4cGVjdChjaHVuay5tZDUpLnRvRXF1YWwodW5kZWZpbmVkKTtcbiAgICBleHBlY3QoY2h1bmsuc3RhcnRCeXRlKS50b0VxdWFsKDEpO1xuICAgIGV4cGVjdChjaHVuay5lbmRCeXRlKS50b0VxdWFsKDMpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlbGVhc2UgZmlsZSBidWZmZXInLCAoKSA9PiB7XG4gICAgZmlsZS5yZWxlYXNlKCk7XG5cbiAgICBleHBlY3QoZmlsZS5idWZmZXIpLnRvRXF1YWwodW5kZWZpbmVkKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXR1cm4ganNvbiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmlsZScsICgpID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShmaWxlKSk7XG5cbiAgICBleHBlY3QoanNvbikudG9FcXVhbCh7XG4gICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgIHR5cGUsXG4gICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXX0=
