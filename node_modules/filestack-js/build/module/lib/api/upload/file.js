import { __assign, __awaiter, __generator } from "tslib";
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { md5, sanitizeName } from './../../utils';
/**
 * File representation to unify file object in nodejs and browser
 *
 * @export
 * @class File
 */
var File = /** @class */ (function () {
    function File(_file, _sanitizeOptions) {
        this._file = _file;
        this._sanitizeOptions = _sanitizeOptions;
        this._file.name = sanitizeName(this._file.name, this._sanitizeOptions);
    }
    Object.defineProperty(File.prototype, "name", {
        /**
         * Returns file name
         *
         * @returns {string}
         * @memberof File
         */
        get: function () {
            return this._file.name;
        },
        /**
         * Sets new file name  and cleanup extra chars
         *
         * @memberof File
         */
        set: function (val) {
            this._file.name = sanitizeName(val, this._sanitizeOptions);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "filename", {
        /**
         * Alias for name getter
         *
         * @readonly
         * @type {string}
         * @memberof File
         */
        get: function () {
            return this.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "customName", {
        /**
         * Sets custom name using string or function
         * Name will be sanitized
         *
         * @memberof File
         */
        set: function (val) {
            switch (typeof val) {
                case 'string':
                    this.name = val;
                    break;
                case 'function':
                    var newName = val(this);
                    if (typeof newName !== 'string') {
                        throw new Error("Name function must return a string. Current return type is " + typeof val);
                    }
                    this.name = val(this);
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "type", {
        /**
         * Returns file type
         *
         * @default 'application/octet-stream'
         * @returns {string}
         * @memberof File
         */
        get: function () {
            /* istanbul ignore next */
            return this._file.type || 'application/octet-stream';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "mimetype", {
        /**
         * Alias for file type
         *
         * @readonly
         * @type {string}
         * @memberof File
         */
        get: function () {
            return this.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "size", {
        /**
         * Returns file size
         *
         * @returns {number}
         * @memberof File
         */
        get: function () {
            return this._file.size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns number of parts according to part size
     *
     * @param {number} size - part size in bytes
     * @returns {number}
     * @memberof File
     */
    File.prototype.getPartsCount = function (size) {
        return Math.ceil(this._file.size / size);
    };
    /**
     * Returns part metadata
     *
     * @param {number} [partNum=0]
     * @param {*} size
     * @returns {FilePartMetadata}
     * @memberof File
     */
    File.prototype.getPartMetadata = function (partNum, size) {
        var startByte = size * partNum;
        if (startByte > this._file.size) {
            throw new Error("Start byte of the part is higher than buffer size");
        }
        var endByte = Math.min(startByte + size, this._file.size);
        return {
            partNumber: partNum,
            startByte: startByte,
            endByte: endByte,
            size: endByte - startByte,
        };
    };
    /**
     * Returns part metadata + buffer
     *
     * @param {FilePartMetadata} meta
     * @returns {FilePart}
     * @memberof File
     */
    File.prototype.getPartByMetadata = function (meta, md5Enabled) {
        if (md5Enabled === void 0) { md5Enabled = true; }
        return __awaiter(this, void 0, void 0, function () {
            var slice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._file.slice(meta.startByte, meta.endByte)];
                    case 1:
                        slice = _a.sent();
                        return [2 /*return*/, Promise.resolve(__assign(__assign({}, meta), { buffer: slice, md5: md5Enabled ? md5(slice) : undefined }))];
                }
            });
        });
    };
    /**
     * Returns part chunk
     *
     * @param {FilePartMetadata} meta
     * @param {number} offset
     * @param {number} chunkSize
     * @returns {FilePart}
     * @memberof File
     */
    File.prototype.getChunkByMetadata = function (meta, offset, chunkSize, md5Enabled) {
        if (md5Enabled === void 0) { md5Enabled = true; }
        return __awaiter(this, void 0, void 0, function () {
            var startByte, endByte, slice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        startByte = meta.startByte + offset;
                        endByte = Math.min(startByte + chunkSize, meta.endByte);
                        return [4 /*yield*/, this._file.slice(startByte, endByte)];
                    case 1:
                        slice = _a.sent();
                        return [2 /*return*/, Promise.resolve(__assign(__assign({}, meta), { buffer: slice, md5: md5Enabled ? md5(slice) : undefined, size: slice.byteLength, startByte: startByte,
                                endByte: endByte,
                                offset: offset }))];
                }
            });
        });
    };
    /**
     * Cleanup file buffer to release memory
     *
     * @memberof File
     */
    File.prototype.release = function () {
        if (this._file.release) {
            this._file.release();
        }
    };
    File.prototype.toJSON = function () {
        return {
            name: this.name,
            status: this.status,
            type: this.type,
            size: this.size,
            url: this.url,
            handle: this.handle,
            uploadTags: this.uploadTags,
        };
    };
    return File;
}());
export { File };

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxPQUFPLEVBQUUsR0FBRyxFQUFFLFlBQVksRUFBbUIsTUFBTSxlQUFlLENBQUM7QUFzQ25FOzs7OztHQUtHO0FBQ0g7SUFnQkUsY0FBNkIsS0FBbUIsRUFBbUIsZ0JBQWtDO1FBQXhFLFVBQUssR0FBTCxLQUFLLENBQWM7UUFBbUIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNuRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDekUsQ0FBQztJQVFELHNCQUFXLHNCQUFJO1FBTmY7Ozs7O1dBS0c7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7UUFDekIsQ0FBQztRQWFEOzs7O1dBSUc7YUFDSCxVQUFnQixHQUFXO1lBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLFlBQVksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDN0QsQ0FBQzs7O09BcEJBO0lBU0Qsc0JBQVcsMEJBQVE7UUFQbkI7Ozs7OztXQU1HO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDbkIsQ0FBQzs7O09BQUE7SUFpQkQsc0JBQVcsNEJBQVU7UUFOckI7Ozs7O1dBS0c7YUFDSCxVQUFzQixHQUFzQztZQUMxRCxRQUFRLE9BQU8sR0FBRyxFQUFFO2dCQUNsQixLQUFLLFFBQVE7b0JBQ1gsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7b0JBQ2hCLE1BQU07Z0JBQ1IsS0FBSyxVQUFVO29CQUNiLElBQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDMUIsSUFB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Q0FBQyxDQUFDLENBQUMsU0FBUyxFQUN4QyxJQUFJLEVBQUUsS0FBSyxDQUFDLFVBQVUsRUFDdEIsU0FBUyxXQUFBO2dDQUNULE9BQU8sU0FBQTtnQ0FDUCxNQUFNLFFBQUEsSUFDTixFQUFDOzs7O0tBQ0o7SUFDRDs7OztPQUlHO0lBQ0ksc0JBQU8sR0FBZDtRQUNFLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUU7WUFDdEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUN0QjtJQUNILENBQUM7SUFFTSxxQkFBTSxHQUFiO1FBQ0UsT0FBTztZQUNMLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtZQUNmLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtZQUNuQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7WUFDYixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07WUFDbkIsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVO1NBQzVCLENBQUM7SUFDSixDQUFDO0lBQ0gsV0FBQztBQUFELENBN01BLEFBNk1DLElBQUEiLCJmaWxlIjoibGliL2FwaS91cGxvYWQvZmlsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBtZDUsIHNhbml0aXplTmFtZSwgU2FuaXRpemVPcHRpb25zIH0gZnJvbSAnLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkVGFncyB7XG4gIFtrZXk6IHN0cmluZ106IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlSW5zdGFuY2Uge1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgc2l6ZTogbnVtYmVyO1xuICBzbGljZTogKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSA9PiBQcm9taXNlPEFycmF5QnVmZmVyPjtcbiAgcmVsZWFzZT86ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIEZpbGVTdGF0ZSB7XG4gIElOSVQgPSAnSW5pdGlhbGl6ZWQnLFxuICBQUk9HUkVTUyA9ICdQcm9ncmVzcycsXG4gIFNUT1JFRCA9ICdTdG9yZWQnLFxuICBJTlRSQU5TSVQgPSAnSW5UcmFuc2l0JyxcbiAgRkFJTEVEID0gJ0ZhaWxlZCcsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVBhcnRNZXRhZGF0YSB7XG4gIHN0YXJ0Qnl0ZTogbnVtYmVyO1xuICBlbmRCeXRlOiBudW1iZXI7XG4gIHBhcnROdW1iZXI6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVQYXJ0IGV4dGVuZHMgRmlsZVBhcnRNZXRhZGF0YSB7XG4gIGJ1ZmZlcjogQnVmZmVyIHwgQXJyYXlCdWZmZXI7XG4gIG1kNT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlQ2h1bmsgZXh0ZW5kcyBGaWxlUGFydCB7XG4gIG9mZnNldDogbnVtYmVyOyAvLyBvZmZzZXQgZm9yIGNodW5rIC0gZnJvbSBwYXJ0IHN0YXJ0XG59XG5cbi8qKlxuICogRmlsZSByZXByZXNlbnRhdGlvbiB0byB1bmlmeSBmaWxlIG9iamVjdCBpbiBub2RlanMgYW5kIGJyb3dzZXJcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgRmlsZVxuICovXG5leHBvcnQgY2xhc3MgRmlsZSB7XG5cbiAgcHVibGljIHN0YXR1czogRmlsZVN0YXRlO1xuXG4gIHB1YmxpYyBoYW5kbGU6IHN0cmluZztcblxuICBwdWJsaWMgdXJsOiBzdHJpbmc7XG5cbiAgcHVibGljIGNvbnRhaW5lcjogc3RyaW5nO1xuXG4gIHB1YmxpYyBrZXk6IHN0cmluZztcblxuICBwdWJsaWMgd29ya2Zsb3dzOiBhbnlbXTtcblxuICBwdWJsaWMgdXBsb2FkVGFnczogVXBsb2FkVGFncztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IF9maWxlOiBGaWxlSW5zdGFuY2UsIHByaXZhdGUgcmVhZG9ubHkgX3Nhbml0aXplT3B0aW9ucz86IFNhbml0aXplT3B0aW9ucykge1xuICAgIHRoaXMuX2ZpbGUubmFtZSA9IHNhbml0aXplTmFtZSh0aGlzLl9maWxlLm5hbWUsIHRoaXMuX3Nhbml0aXplT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmaWxlIG5hbWVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9maWxlLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIG5hbWUgZ2V0dGVyXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGdldCBmaWxlbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBuZXcgZmlsZSBuYW1lICBhbmQgY2xlYW51cCBleHRyYSBjaGFyc1xuICAgKlxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIHNldCBuYW1lKHZhbDogc3RyaW5nKSB7XG4gICAgdGhpcy5fZmlsZS5uYW1lID0gc2FuaXRpemVOYW1lKHZhbCwgdGhpcy5fc2FuaXRpemVPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGN1c3RvbSBuYW1lIHVzaW5nIHN0cmluZyBvciBmdW5jdGlvblxuICAgKiBOYW1lIHdpbGwgYmUgc2FuaXRpemVkXG4gICAqXG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgc2V0IGN1c3RvbU5hbWUodmFsOiAoKGZpbGU6IHRoaXMpID0+IHN0cmluZykgfCBzdHJpbmcpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHRoaXMubmFtZSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIGNvbnN0IG5ld05hbWUgPSB2YWwodGhpcyk7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3TmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzdHJpbmcuIEN1cnJlbnQgcmV0dXJuIHR5cGUgaXMgJHt0eXBlb2YgdmFsfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYW1lID0gdmFsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmaWxlIHR5cGVcbiAgICpcbiAgICogQGRlZmF1bHQgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBnZXQgdHlwZSgpOiBzdHJpbmcge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuX2ZpbGUudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgZmlsZSB0eXBlXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGdldCBtaW1ldHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmaWxlIHNpemVcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9maWxlLnNpemU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBudW1iZXIgb2YgcGFydHMgYWNjb3JkaW5nIHRvIHBhcnQgc2l6ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIHBhcnQgc2l6ZSBpbiBieXRlc1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGdldFBhcnRzQ291bnQgKHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLl9maWxlLnNpemUgLyBzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcnQgbWV0YWRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJ0TnVtPTBdXG4gICAqIEBwYXJhbSB7Kn0gc2l6ZVxuICAgKiBAcmV0dXJucyB7RmlsZVBhcnRNZXRhZGF0YX1cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBnZXRQYXJ0TWV0YWRhdGEgKHBhcnROdW06IG51bWJlciwgc2l6ZTogbnVtYmVyKTogRmlsZVBhcnRNZXRhZGF0YSB7XG4gICAgY29uc3Qgc3RhcnRCeXRlID0gc2l6ZSAqIHBhcnROdW07XG5cbiAgICBpZiAoc3RhcnRCeXRlID4gdGhpcy5fZmlsZS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXJ0IGJ5dGUgb2YgdGhlIHBhcnQgaXMgaGlnaGVyIHRoYW4gYnVmZmVyIHNpemVgKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmRCeXRlID0gTWF0aC5taW4oc3RhcnRCeXRlICsgc2l6ZSwgdGhpcy5fZmlsZS5zaXplKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXJ0TnVtYmVyOiBwYXJ0TnVtLFxuICAgICAgc3RhcnRCeXRlLFxuICAgICAgZW5kQnl0ZSxcbiAgICAgIHNpemU6IGVuZEJ5dGUgLSBzdGFydEJ5dGUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcnQgbWV0YWRhdGEgKyBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIHtGaWxlUGFydE1ldGFkYXRhfSBtZXRhXG4gICAqIEByZXR1cm5zIHtGaWxlUGFydH1cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRQYXJ0QnlNZXRhZGF0YShtZXRhOiBGaWxlUGFydE1ldGFkYXRhLCBtZDVFbmFibGVkOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8RmlsZVBhcnQ+IHtcbiAgICBsZXQgc2xpY2UgPSBhd2FpdCB0aGlzLl9maWxlLnNsaWNlKG1ldGEuc3RhcnRCeXRlLCBtZXRhLmVuZEJ5dGUpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAuLi5tZXRhLFxuICAgICAgYnVmZmVyOiBzbGljZSxcbiAgICAgIG1kNTogbWQ1RW5hYmxlZCA/IG1kNShzbGljZSkgOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBwYXJ0IGNodW5rXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZVBhcnRNZXRhZGF0YX0gbWV0YVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua1NpemVcbiAgICogQHJldHVybnMge0ZpbGVQYXJ0fVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldENodW5rQnlNZXRhZGF0YShtZXRhOiBGaWxlUGFydE1ldGFkYXRhLCBvZmZzZXQ6IG51bWJlciwgY2h1bmtTaXplOiBudW1iZXIsIG1kNUVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTxGaWxlQ2h1bms+IHtcbiAgICBjb25zdCBzdGFydEJ5dGUgPSBtZXRhLnN0YXJ0Qnl0ZSArIG9mZnNldDtcbiAgICBjb25zdCBlbmRCeXRlID0gTWF0aC5taW4oc3RhcnRCeXRlICsgY2h1bmtTaXplLCBtZXRhLmVuZEJ5dGUpO1xuXG4gICAgbGV0IHNsaWNlID0gYXdhaXQgdGhpcy5fZmlsZS5zbGljZShzdGFydEJ5dGUsIGVuZEJ5dGUpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAuLi5tZXRhLFxuICAgICAgYnVmZmVyOiBzbGljZSxcbiAgICAgIG1kNTogbWQ1RW5hYmxlZCA/IG1kNShzbGljZSkgOiB1bmRlZmluZWQsXG4gICAgICBzaXplOiBzbGljZS5ieXRlTGVuZ3RoLFxuICAgICAgc3RhcnRCeXRlLFxuICAgICAgZW5kQnl0ZSxcbiAgICAgIG9mZnNldCxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2xlYW51cCBmaWxlIGJ1ZmZlciB0byByZWxlYXNlIG1lbW9yeVxuICAgKlxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIHJlbGVhc2UoKSB7XG4gICAgaWYgKHRoaXMuX2ZpbGUucmVsZWFzZSkge1xuICAgICAgdGhpcy5fZmlsZS5yZWxlYXNlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoYW5kbGU6IHRoaXMuaGFuZGxlLFxuICAgICAgdXBsb2FkVGFnczogdGhpcy51cGxvYWRUYWdzLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==
