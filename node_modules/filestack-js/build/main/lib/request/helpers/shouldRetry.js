"use strict";
/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var error_1 = require("./../error");
var debug_1 = require("debug");
var debug = debug_1.default('fs:request:shouldRetry');
/**
 * Indicates if method should be retried
 *
 * @private
 * @param {FsRequestError} err
 * @returns
 * @memberof Dispatch
 */
exports.shouldRetry = function (err) {
    debug('Checking error for retry. Code: %n, type: %s', (err.response ? err.response.status : 'Malformed response'), err.code);
    // we always should retry on network failure
    switch (err.code) {
        case error_1.FsRequestErrorCode.NETWORK:
        case error_1.FsRequestErrorCode.SERVER:
        case error_1.FsRequestErrorCode.TIMEOUT:
            return true;
        // we should not make request on request aborted
        case error_1.FsRequestErrorCode.ABORTED:
            return false;
    }
    if (!err.response) {
        return false;
    }
    // we should retry on all server errors (5xx)
    // this should be handled by FsRequestErrorCode.SERVER but to be sure
    if (500 <= err.response.status && err.response.status <= 599) {
        return true;
    }
    // we should not retry on other errors (4xx) ie: BadRequest etc
    return false;
};

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9oZWxwZXJzL3Nob3VsZFJldHJ5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7O0FBRUgsb0NBQWdFO0FBQ2hFLCtCQUEwQjtBQUUxQixJQUFNLEtBQUssR0FBRyxlQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUU5Qzs7Ozs7OztHQU9HO0FBQ1UsUUFBQSxXQUFXLEdBQUcsVUFBQyxHQUFtQjtJQUM3QyxLQUFLLENBQUMsOENBQThDLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsb0JBQW9CLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFN0gsNENBQTRDO0lBQzVDLFFBQVEsR0FBRyxDQUFDLElBQUksRUFBRTtRQUNoQixLQUFLLDBCQUFrQixDQUFDLE9BQU8sQ0FBQztRQUNoQyxLQUFLLDBCQUFrQixDQUFDLE1BQU0sQ0FBQztRQUMvQixLQUFLLDBCQUFrQixDQUFDLE9BQU87WUFDN0IsT0FBTyxJQUFJLENBQUM7UUFDZCxnREFBZ0Q7UUFDaEQsS0FBSywwQkFBa0IsQ0FBQyxPQUFPO1lBQzdCLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0lBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUU7UUFDakIsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELDZDQUE2QztJQUM3QyxxRUFBcUU7SUFDckUsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksR0FBRyxFQUFFO1FBQzVELE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCwrREFBK0Q7SUFDL0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDLENBQUMiLCJmaWxlIjoibGliL3JlcXVlc3QvaGVscGVycy9zaG91bGRSZXRyeS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRnNSZXF1ZXN0RXJyb3IsIEZzUmVxdWVzdEVycm9yQ29kZSB9IGZyb20gJy4vLi4vZXJyb3InO1xuaW1wb3J0IERlYnVnIGZyb20gJ2RlYnVnJztcblxuY29uc3QgZGVidWcgPSBEZWJ1ZygnZnM6cmVxdWVzdDpzaG91bGRSZXRyeScpO1xuXG4vKipcbiAqIEluZGljYXRlcyBpZiBtZXRob2Qgc2hvdWxkIGJlIHJldHJpZWRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGc1JlcXVlc3RFcnJvcn0gZXJyXG4gKiBAcmV0dXJuc1xuICogQG1lbWJlcm9mIERpc3BhdGNoXG4gKi9cbmV4cG9ydCBjb25zdCBzaG91bGRSZXRyeSA9IChlcnI6IEZzUmVxdWVzdEVycm9yKSA9PiB7XG4gIGRlYnVnKCdDaGVja2luZyBlcnJvciBmb3IgcmV0cnkuIENvZGU6ICVuLCB0eXBlOiAlcycsIChlcnIucmVzcG9uc2UgPyBlcnIucmVzcG9uc2Uuc3RhdHVzIDogJ01hbGZvcm1lZCByZXNwb25zZScpLCBlcnIuY29kZSk7XG5cbiAgLy8gd2UgYWx3YXlzIHNob3VsZCByZXRyeSBvbiBuZXR3b3JrIGZhaWx1cmVcbiAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgIGNhc2UgRnNSZXF1ZXN0RXJyb3JDb2RlLk5FVFdPUks6XG4gICAgY2FzZSBGc1JlcXVlc3RFcnJvckNvZGUuU0VSVkVSOlxuICAgIGNhc2UgRnNSZXF1ZXN0RXJyb3JDb2RlLlRJTUVPVVQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyB3ZSBzaG91bGQgbm90IG1ha2UgcmVxdWVzdCBvbiByZXF1ZXN0IGFib3J0ZWRcbiAgICBjYXNlIEZzUmVxdWVzdEVycm9yQ29kZS5BQk9SVEVEOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFlcnIucmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB3ZSBzaG91bGQgcmV0cnkgb24gYWxsIHNlcnZlciBlcnJvcnMgKDV4eClcbiAgLy8gdGhpcyBzaG91bGQgYmUgaGFuZGxlZCBieSBGc1JlcXVlc3RFcnJvckNvZGUuU0VSVkVSIGJ1dCB0byBiZSBzdXJlXG4gIGlmICg1MDAgPD0gZXJyLnJlc3BvbnNlLnN0YXR1cyAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzIDw9IDU5OSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gd2Ugc2hvdWxkIG5vdCByZXRyeSBvbiBvdGhlciBlcnJvcnMgKDR4eCkgaWU6IEJhZFJlcXVlc3QgZXRjXG4gIHJldHVybiBmYWxzZTtcbn07XG4iXX0=
