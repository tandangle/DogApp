/// <reference types="node" />
import { SanitizeOptions } from './../../utils';
export interface UploadTags {
    [key: string]: string;
}
export interface FileInstance {
    name: string;
    type: string;
    size: number;
    slice: (start: number, end: number) => Promise<ArrayBuffer>;
    release?: () => void;
}
export declare const enum FileState {
    INIT = "Initialized",
    PROGRESS = "Progress",
    STORED = "Stored",
    INTRANSIT = "InTransit",
    FAILED = "Failed"
}
export interface FilePartMetadata {
    startByte: number;
    endByte: number;
    partNumber: number;
    size: number;
}
export interface FilePart extends FilePartMetadata {
    buffer: Buffer | ArrayBuffer;
    md5?: string;
}
export interface FileChunk extends FilePart {
    offset: number;
}
/**
 * File representation to unify file object in nodejs and browser
 *
 * @export
 * @class File
 */
export declare class File {
    private readonly _file;
    private readonly _sanitizeOptions?;
    status: FileState;
    handle: string;
    url: string;
    container: string;
    key: string;
    workflows: any[];
    uploadTags: UploadTags;
    constructor(_file: FileInstance, _sanitizeOptions?: SanitizeOptions);
    /**
     * Returns file name
     *
     * @returns {string}
     * @memberof File
     */
    get name(): string;
    /**
     * Alias for name getter
     *
     * @readonly
     * @type {string}
     * @memberof File
     */
    get filename(): string;
    /**
     * Sets new file name  and cleanup extra chars
     *
     * @memberof File
     */
    set name(val: string);
    /**
     * Sets custom name using string or function
     * Name will be sanitized
     *
     * @memberof File
     */
    set customName(val: ((file: this) => string) | string);
    /**
     * Returns file type
     *
     * @default 'application/octet-stream'
     * @returns {string}
     * @memberof File
     */
    get type(): string;
    /**
     * Alias for file type
     *
     * @readonly
     * @type {string}
     * @memberof File
     */
    get mimetype(): string;
    /**
     * Returns file size
     *
     * @returns {number}
     * @memberof File
     */
    get size(): number;
    /**
     * Returns number of parts according to part size
     *
     * @param {number} size - part size in bytes
     * @returns {number}
     * @memberof File
     */
    getPartsCount(size: number): number;
    /**
     * Returns part metadata
     *
     * @param {number} [partNum=0]
     * @param {*} size
     * @returns {FilePartMetadata}
     * @memberof File
     */
    getPartMetadata(partNum: number, size: number): FilePartMetadata;
    /**
     * Returns part metadata + buffer
     *
     * @param {FilePartMetadata} meta
     * @returns {FilePart}
     * @memberof File
     */
    getPartByMetadata(meta: FilePartMetadata, md5Enabled?: boolean): Promise<FilePart>;
    /**
     * Returns part chunk
     *
     * @param {FilePartMetadata} meta
     * @param {number} offset
     * @param {number} chunkSize
     * @returns {FilePart}
     * @memberof File
     */
    getChunkByMetadata(meta: FilePartMetadata, offset: number, chunkSize: number, md5Enabled?: boolean): Promise<FileChunk>;
    /**
     * Cleanup file buffer to release memory
     *
     * @memberof File
     */
    release(): void;
    toJSON(): {
        name: string;
        status: FileState;
        type: string;
        size: number;
        url: string;
        handle: string;
        uploadTags: UploadTags;
    };
}
